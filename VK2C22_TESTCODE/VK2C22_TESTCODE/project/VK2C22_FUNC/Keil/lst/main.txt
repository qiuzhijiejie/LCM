; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M451Series\Include -I..\..\..\Library\StdDriver\inc -I..\Bsp -I..\User -I..\lcd_driver -I..\exti_driver -I..\led_driver -I..\touch -I..\dotmatix_lcd -I..\KH -I.\RTE\_project -ID:\KEIL_STM32\Packs\ARM\CMSIS\6.1.0\CMSIS\Core\Include -D__UVISION_VERSION=541 -D_RTE_ --omf_browse=.\obj\main.crf ..\User\main.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  I2C0_IRQHandler PROC
;;;39     /*---------------------------------------------------------------------------------------------------------*/
;;;40     void I2C0_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;41     {
;;;42         unsigned int status;
;;;43     
;;;44         status = I2C_GET_STATUS(I2C0);
000002  48e0              LDR      r0,|L1.900|
000004  68c4              LDR      r4,[r0,#0xc]
;;;45         if(I2C_GET_TIMEOUT_FLAG(I2C0))
000006  6940              LDR      r0,[r0,#0x14]
000008  f0000001          AND      r0,r0,#1
00000c  b118              CBZ      r0,|L1.22|
;;;46         {
;;;47             /* Clear I2C0 Timeout Flag */
;;;48             I2C_ClearTimeoutFlag(I2C0);
00000e  48dd              LDR      r0,|L1.900|
000010  f7fffffe          BL       I2C_ClearTimeoutFlag
000014  e006              B        |L1.36|
                  |L1.22|
;;;49         }
;;;50         else
;;;51         {
;;;52             if(i2c0handlerflag != NULL)
000016  48dc              LDR      r0,|L1.904|
000018  6800              LDR      r0,[r0,#0]  ; i2c0handlerflag
00001a  b118              CBZ      r0,|L1.36|
;;;53                 i2c0handlerflag(status);
00001c  4620              MOV      r0,r4
00001e  49da              LDR      r1,|L1.904|
000020  6809              LDR      r1,[r1,#0]  ; i2c0handlerflag
000022  4788              BLX      r1
                  |L1.36|
;;;54         }
;;;55     }
000024  bd10              POP      {r4,pc}
;;;56     
                          ENDP

                  I2C_MasterRx PROC
;;;59     /*---------------------------------------------------------------------------------------------------------*/
;;;60     void I2C_MasterRx(unsigned int rxstatus)
000026  b510              PUSH     {r4,lr}
;;;61     {
000028  4604              MOV      r4,r0
;;;62         if(rxstatus == 0x08)                       /* START has been transmitted and prepare SLA+W */
00002a  2c08              CMP      r4,#8
00002c  d10a              BNE      |L1.68|
;;;63         {
;;;64             I2C_SET_DATA(I2C0, (VK2C22_ADDR << 1));    /* Write SLA+W to Register I2CDAT */
00002e  207e              MOVS     r0,#0x7e
000030  49d4              LDR      r1,|L1.900|
000032  6088              STR      r0,[r1,#8]
;;;65             I2C_SET_CONTROL_REG(I2C0, I2C_CTL_SI);
000034  4608              MOV      r0,r1
000036  6800              LDR      r0,[r0,#0]
000038  f020003c          BIC      r0,r0,#0x3c
00003c  f0400008          ORR      r0,r0,#8
000040  6008              STR      r0,[r1,#0]
000042  e086              B        |L1.338|
                  |L1.68|
;;;66         }
;;;67         else if(rxstatus == 0x18)                  /* SLA+W has been transmitted and ACK has been received */
000044  2c18              CMP      r4,#0x18
000046  d111              BNE      |L1.108|
;;;68         {
;;;69             I2C_SET_DATA(I2C0, i2cdatbuf[txcnt++]);
000048  48d0              LDR      r0,|L1.908|
00004a  7801              LDRB     r1,[r0,#0]  ; txcnt
00004c  7800              LDRB     r0,[r0,#0]  ; txcnt
00004e  1c40              ADDS     r0,r0,#1
000050  4ace              LDR      r2,|L1.908|
000052  7010              STRB     r0,[r2,#0]
000054  48ce              LDR      r0,|L1.912|
000056  5c40              LDRB     r0,[r0,r1]
000058  49ca              LDR      r1,|L1.900|
00005a  6088              STR      r0,[r1,#8]
;;;70             I2C_SET_CONTROL_REG(I2C0, I2C_CTL_SI);
00005c  4608              MOV      r0,r1
00005e  6800              LDR      r0,[r0,#0]
000060  f020003c          BIC      r0,r0,#0x3c
000064  f0400008          ORR      r0,r0,#8
000068  6008              STR      r0,[r1,#0]
00006a  e072              B        |L1.338|
                  |L1.108|
;;;71         }
;;;72         else if(rxstatus == 0x20)                  /* SLA+W has been transmitted and NACK has been received */
00006c  2c20              CMP      r4,#0x20
00006e  d10b              BNE      |L1.136|
;;;73         {
;;;74             I2C_STOP(I2C0);
000070  48c4              LDR      r0,|L1.900|
000072  f7fffffe          BL       I2C_STOP
;;;75             I2C_START(I2C0);
000076  48c3              LDR      r0,|L1.900|
000078  6800              LDR      r0,[r0,#0]
00007a  f0200008          BIC      r0,r0,#8
00007e  f0400020          ORR      r0,r0,#0x20
000082  49c0              LDR      r1,|L1.900|
000084  6008              STR      r0,[r1,#0]
000086  e064              B        |L1.338|
                  |L1.136|
;;;76         }
;;;77         else if(rxstatus == 0x28)                  /* DATA has been transmitted and ACK has been received */
000088  2c28              CMP      r4,#0x28
00008a  d120              BNE      |L1.206|
;;;78         {
;;;79             if(txcnt != txlen)
00008c  48bf              LDR      r0,|L1.908|
00008e  7800              LDRB     r0,[r0,#0]  ; txcnt
000090  49c0              LDR      r1,|L1.916|
000092  7809              LDRB     r1,[r1,#0]  ; txlen
000094  4288              CMP      r0,r1
000096  d011              BEQ      |L1.188|
;;;80             {
;;;81                 I2C_SET_DATA(I2C0, i2cdatbuf[txcnt++]);
000098  48bc              LDR      r0,|L1.908|
00009a  7801              LDRB     r1,[r0,#0]  ; txcnt
00009c  7800              LDRB     r0,[r0,#0]  ; txcnt
00009e  1c40              ADDS     r0,r0,#1
0000a0  4aba              LDR      r2,|L1.908|
0000a2  7010              STRB     r0,[r2,#0]
0000a4  48ba              LDR      r0,|L1.912|
0000a6  5c40              LDRB     r0,[r0,r1]
0000a8  49b6              LDR      r1,|L1.900|
0000aa  6088              STR      r0,[r1,#8]
;;;82                 I2C_SET_CONTROL_REG(I2C0, I2C_CTL_SI);
0000ac  4608              MOV      r0,r1
0000ae  6800              LDR      r0,[r0,#0]
0000b0  f020003c          BIC      r0,r0,#0x3c
0000b4  f0400008          ORR      r0,r0,#8
0000b8  6008              STR      r0,[r1,#0]
0000ba  e04a              B        |L1.338|
                  |L1.188|
;;;83             }
;;;84             else
;;;85             {
;;;86                 I2C_SET_CONTROL_REG(I2C0, I2C_CTL_STA_SI);
0000bc  48b1              LDR      r0,|L1.900|
0000be  6800              LDR      r0,[r0,#0]
0000c0  f020003c          BIC      r0,r0,#0x3c
0000c4  f0400028          ORR      r0,r0,#0x28
0000c8  49ae              LDR      r1,|L1.900|
0000ca  6008              STR      r0,[r1,#0]
0000cc  e041              B        |L1.338|
                  |L1.206|
;;;87             }
;;;88         }
;;;89         else if(rxstatus == 0x10)                  /* Repeat START has been transmitted and prepare SLA+R */
0000ce  2c10              CMP      r4,#0x10
0000d0  d10a              BNE      |L1.232|
;;;90         {
;;;91             I2C_SET_DATA(I2C0, ((VK2C22_ADDR << 1) | 0x01));   /* Write SLA+R to Register I2CDAT */
0000d2  207f              MOVS     r0,#0x7f
0000d4  49ab              LDR      r1,|L1.900|
0000d6  6088              STR      r0,[r1,#8]
;;;92             I2C_SET_CONTROL_REG(I2C0, I2C_CTL_SI);
0000d8  4608              MOV      r0,r1
0000da  6800              LDR      r0,[r0,#0]
0000dc  f020003c          BIC      r0,r0,#0x3c
0000e0  f0400008          ORR      r0,r0,#8
0000e4  6008              STR      r0,[r1,#0]
0000e6  e034              B        |L1.338|
                  |L1.232|
;;;93         }
;;;94         else if(rxstatus == 0x40)                  /* SLA+R has been transmitted and ACK has been received */
0000e8  2c40              CMP      r4,#0x40
0000ea  d108              BNE      |L1.254|
;;;95         {
;;;96             I2C_SET_CONTROL_REG(I2C0, I2C_CTL_SI);
0000ec  48a5              LDR      r0,|L1.900|
0000ee  6800              LDR      r0,[r0,#0]
0000f0  f020003c          BIC      r0,r0,#0x3c
0000f4  f0400008          ORR      r0,r0,#8
0000f8  49a2              LDR      r1,|L1.900|
0000fa  6008              STR      r0,[r1,#0]
0000fc  e029              B        |L1.338|
                  |L1.254|
;;;97         }
;;;98         else if(rxstatus == 0x58)                  /* DATA has been received and NACK has been returned */
0000fe  2c58              CMP      r4,#0x58
000100  d127              BNE      |L1.338|
;;;99         {
;;;100    			i2cdatbuf[rxcnt+txlen] = (unsigned char) I2C_GET_DATA(I2C0);
000102  48a0              LDR      r0,|L1.900|
000104  6880              LDR      r0,[r0,#8]
000106  49a4              LDR      r1,|L1.920|
000108  7809              LDRB     r1,[r1,#0]  ; rxcnt
00010a  4aa2              LDR      r2,|L1.916|
00010c  7812              LDRB     r2,[r2,#0]  ; txlen
00010e  4411              ADD      r1,r1,r2
000110  4a9f              LDR      r2,|L1.912|
000112  5450              STRB     r0,[r2,r1]
;;;101    			rxcnt++; 
000114  48a0              LDR      r0,|L1.920|
000116  7800              LDRB     r0,[r0,#0]  ; rxcnt
000118  1c40              ADDS     r0,r0,#1
00011a  499f              LDR      r1,|L1.920|
00011c  7008              STRB     r0,[r1,#0]
;;;102    			if(rxcnt != rxlen)
00011e  4608              MOV      r0,r1
000120  7800              LDRB     r0,[r0,#0]  ; rxcnt
000122  499e              LDR      r1,|L1.924|
000124  7809              LDRB     r1,[r1,#0]  ; rxlen
000126  4288              CMP      r0,r1
000128  d008              BEQ      |L1.316|
;;;103    			{
;;;104    				I2C_SET_CONTROL_REG(I2C0, I2C_CTL_STO);
00012a  4896              LDR      r0,|L1.900|
00012c  6800              LDR      r0,[r0,#0]
00012e  f020003c          BIC      r0,r0,#0x3c
000132  f0400010          ORR      r0,r0,#0x10
000136  4993              LDR      r1,|L1.900|
000138  6008              STR      r0,[r1,#0]
00013a  e00a              B        |L1.338|
                  |L1.316|
;;;105    			}
;;;106    			else
;;;107    			{
;;;108    				I2C_SET_CONTROL_REG(I2C0, I2C_CTL_STO_SI);
00013c  4891              LDR      r0,|L1.900|
00013e  6800              LDR      r0,[r0,#0]
000140  f020003c          BIC      r0,r0,#0x3c
000144  f0400018          ORR      r0,r0,#0x18
000148  498e              LDR      r1,|L1.900|
00014a  6008              STR      r0,[r1,#0]
;;;109    				endflag = 1;
00014c  2001              MOVS     r0,#1
00014e  4994              LDR      r1,|L1.928|
000150  7008              STRB     r0,[r1,#0]
                  |L1.338|
;;;110    			}
;;;111        }
;;;112        else
;;;113        {
;;;114            /* TO DO */
;;;115            //rxstatusis NOT processed
;;;116        }
;;;117    }
000152  bd10              POP      {r4,pc}
;;;118    
                          ENDP

                  I2C_MasterTx PROC
;;;121    /*---------------------------------------------------------------------------------------------------------*/
;;;122    void I2C_MasterTx(unsigned int txstatus)
000154  b510              PUSH     {r4,lr}
;;;123    {
000156  4604              MOV      r4,r0
;;;124        if(txstatus == 0x08)                       /* START has been transmitted */
000158  2c08              CMP      r4,#8
00015a  d10a              BNE      |L1.370|
;;;125        {
;;;126            I2C_SET_DATA(I2C0, VK2C22_ADDR << 1);    /* Write SLA+W to Register I2CDAT */
00015c  207e              MOVS     r0,#0x7e
00015e  4989              LDR      r1,|L1.900|
000160  6088              STR      r0,[r1,#8]
;;;127            I2C_SET_CONTROL_REG(I2C0, I2C_CTL_SI);
000162  4608              MOV      r0,r1
000164  6800              LDR      r0,[r0,#0]
000166  f020003c          BIC      r0,r0,#0x3c
00016a  f0400008          ORR      r0,r0,#8
00016e  6008              STR      r0,[r1,#0]
000170  e046              B        |L1.512|
                  |L1.370|
;;;128        }
;;;129        else if(txstatus == 0x18)                  /* SLA+W has been transmitted and ACK has been received */
000172  2c18              CMP      r4,#0x18
000174  d111              BNE      |L1.410|
;;;130        {
;;;131            I2C_SET_DATA(I2C0, i2cdatbuf[txcnt++]);
000176  4885              LDR      r0,|L1.908|
000178  7801              LDRB     r1,[r0,#0]  ; txcnt
00017a  7800              LDRB     r0,[r0,#0]  ; txcnt
00017c  1c40              ADDS     r0,r0,#1
00017e  4a83              LDR      r2,|L1.908|
000180  7010              STRB     r0,[r2,#0]
000182  4883              LDR      r0,|L1.912|
000184  5c40              LDRB     r0,[r0,r1]
000186  497f              LDR      r1,|L1.900|
000188  6088              STR      r0,[r1,#8]
;;;132            I2C_SET_CONTROL_REG(I2C0, I2C_CTL_SI);
00018a  4608              MOV      r0,r1
00018c  6800              LDR      r0,[r0,#0]
00018e  f020003c          BIC      r0,r0,#0x3c
000192  f0400008          ORR      r0,r0,#8
000196  6008              STR      r0,[r1,#0]
000198  e032              B        |L1.512|
                  |L1.410|
;;;133        }
;;;134        else if(txstatus == 0x20)                  /* SLA+W has been transmitted and NACK has been received */
00019a  2c20              CMP      r4,#0x20
00019c  d10b              BNE      |L1.438|
;;;135        {
;;;136            I2C_STOP(I2C0);
00019e  4879              LDR      r0,|L1.900|
0001a0  f7fffffe          BL       I2C_STOP
;;;137            I2C_START(I2C0);
0001a4  4877              LDR      r0,|L1.900|
0001a6  6800              LDR      r0,[r0,#0]
0001a8  f0200008          BIC      r0,r0,#8
0001ac  f0400020          ORR      r0,r0,#0x20
0001b0  4974              LDR      r1,|L1.900|
0001b2  6008              STR      r0,[r1,#0]
0001b4  e024              B        |L1.512|
                  |L1.438|
;;;138        }
;;;139        else if(txstatus == 0x28)                  /* DATA has been transmitted and ACK has been received */
0001b6  2c28              CMP      r4,#0x28
0001b8  d122              BNE      |L1.512|
;;;140        {
;;;141            if(txcnt != txlen)
0001ba  4874              LDR      r0,|L1.908|
0001bc  7800              LDRB     r0,[r0,#0]  ; txcnt
0001be  4975              LDR      r1,|L1.916|
0001c0  7809              LDRB     r1,[r1,#0]  ; txlen
0001c2  4288              CMP      r0,r1
0001c4  d011              BEQ      |L1.490|
;;;142            {
;;;143                I2C_SET_DATA(I2C0, i2cdatbuf[txcnt++]);
0001c6  4871              LDR      r0,|L1.908|
0001c8  7801              LDRB     r1,[r0,#0]  ; txcnt
0001ca  7800              LDRB     r0,[r0,#0]  ; txcnt
0001cc  1c40              ADDS     r0,r0,#1
0001ce  4a6f              LDR      r2,|L1.908|
0001d0  7010              STRB     r0,[r2,#0]
0001d2  486f              LDR      r0,|L1.912|
0001d4  5c40              LDRB     r0,[r0,r1]
0001d6  496b              LDR      r1,|L1.900|
0001d8  6088              STR      r0,[r1,#8]
;;;144                I2C_SET_CONTROL_REG(I2C0, I2C_CTL_SI);
0001da  4608              MOV      r0,r1
0001dc  6800              LDR      r0,[r0,#0]
0001de  f020003c          BIC      r0,r0,#0x3c
0001e2  f0400008          ORR      r0,r0,#8
0001e6  6008              STR      r0,[r1,#0]
0001e8  e00a              B        |L1.512|
                  |L1.490|
;;;145            }
;;;146            else
;;;147            {
;;;148                I2C_SET_CONTROL_REG(I2C0, I2C_CTL_STO_SI);
0001ea  4866              LDR      r0,|L1.900|
0001ec  6800              LDR      r0,[r0,#0]
0001ee  f020003c          BIC      r0,r0,#0x3c
0001f2  f0400018          ORR      r0,r0,#0x18
0001f6  4963              LDR      r1,|L1.900|
0001f8  6008              STR      r0,[r1,#0]
;;;149                endflag = 1;
0001fa  2001              MOVS     r0,#1
0001fc  4968              LDR      r1,|L1.928|
0001fe  7008              STRB     r0,[r1,#0]
                  |L1.512|
;;;150            }
;;;151        }
;;;152        else
;;;153        {
;;;154           /* TO DO */
;;;155          //txstatus is NOT processed
;;;156        }
;;;157    }
000200  bd10              POP      {r4,pc}
;;;158    /*******************************************************************************
                          ENDP

                  VK2C22_I2C_WRCmd PROC
;;;164    *******************************************************************************/
;;;165    void VK2C22_I2C_WRCmd(unsigned char Cmd)
000202  4963              LDR      r1,|L1.912|
;;;166    {
;;;167    	i2cdatbuf[0] = Cmd;  
000204  7008              STRB     r0,[r1,#0]
;;;168    	txcnt = 0;
000206  2100              MOVS     r1,#0
000208  4a60              LDR      r2,|L1.908|
00020a  7011              STRB     r1,[r2,#0]
;;;169    	txlen = 1;
00020c  2101              MOVS     r1,#1
00020e  4a61              LDR      r2,|L1.916|
000210  7011              STRB     r1,[r2,#0]
;;;170    	endflag = 0;
000212  2100              MOVS     r1,#0
000214  4a62              LDR      r2,|L1.928|
000216  7011              STRB     r1,[r2,#0]
;;;171    
;;;172    	/* I2C function to write data to slave */
;;;173    	i2c0handlerflag = (I2C_FUNC)I2C_MasterTx;
000218  f2af01c7          ADR      r1,I2C_MasterTx + 1
00021c  4a5a              LDR      r2,|L1.904|
00021e  6011              STR      r1,[r2,#0]  ; i2c0handlerflag
;;;174    
;;;175    	/* I2C as master sends START signal */
;;;176    	I2C_SET_CONTROL_REG(I2C0, I2C_CTL_STA);
000220  4958              LDR      r1,|L1.900|
000222  6809              LDR      r1,[r1,#0]
000224  f021013c          BIC      r1,r1,#0x3c
000228  f0410120          ORR      r1,r1,#0x20
00022c  4a55              LDR      r2,|L1.900|
00022e  6011              STR      r1,[r2,#0]
;;;177    	
;;;178    	/* Wait I2C Tx Finish */
;;;179    	while(endflag == 0);
000230  bf00              NOP      
                  |L1.562|
000232  495b              LDR      r1,|L1.928|
000234  7809              LDRB     r1,[r1,#0]  ; endflag
000236  2900              CMP      r1,#0
000238  d0fb              BEQ      |L1.562|
;;;180    	endflag = 0;
00023a  2100              MOVS     r1,#0
00023c  4a58              LDR      r2,|L1.928|
00023e  7011              STRB     r1,[r2,#0]
;;;181    }
000240  4770              BX       lr
;;;182    /*******************************************************************************
                          ENDP

                  VK2C22_I2C_WRDat PROC
;;;188    *******************************************************************************/
;;;189    void VK2C22_I2C_WRDat(unsigned char Addr,unsigned char *Databuf,unsigned char cnt)
000242  b570              PUSH     {r4-r6,lr}
;;;190    {
000244  4603              MOV      r3,r0
;;;191    	unsigned char i;  	
;;;192    	i2cdatbuf[0] = Addr;
000246  4c52              LDR      r4,|L1.912|
000248  7023              STRB     r3,[r4,#0]
;;;193    	for(i=0;i<cnt;i++)
00024a  2000              MOVS     r0,#0
00024c  e005              B        |L1.602|
                  |L1.590|
;;;194    	{
;;;195    		i2cdatbuf[1+i] = *Databuf++;  
00024e  f8115b01          LDRB     r5,[r1],#1
000252  1c44              ADDS     r4,r0,#1
000254  4e4e              LDR      r6,|L1.912|
000256  5535              STRB     r5,[r6,r4]
000258  b2e0              UXTB     r0,r4                 ;193
                  |L1.602|
00025a  4290              CMP      r0,r2                 ;193
00025c  dbf7              BLT      |L1.590|
;;;196    	}
;;;197    	txcnt = 0;
00025e  2400              MOVS     r4,#0
000260  4d4a              LDR      r5,|L1.908|
000262  702c              STRB     r4,[r5,#0]
;;;198    	txlen=cnt+1; 
000264  1c54              ADDS     r4,r2,#1
000266  4d4b              LDR      r5,|L1.916|
000268  702c              STRB     r4,[r5,#0]
;;;199    	endflag = 0;
00026a  2400              MOVS     r4,#0
00026c  4d4c              LDR      r5,|L1.928|
00026e  702c              STRB     r4,[r5,#0]
;;;200    
;;;201    	/* I2C function to write data to slave */
;;;202    	i2c0handlerflag = (I2C_FUNC)I2C_MasterTx;
000270  f2af141f          ADR      r4,I2C_MasterTx + 1
000274  4d44              LDR      r5,|L1.904|
000276  602c              STR      r4,[r5,#0]  ; i2c0handlerflag
;;;203    
;;;204    	/* I2C as master sends START signal */
;;;205    	I2C_SET_CONTROL_REG(I2C0, I2C_CTL_STA);
000278  4c42              LDR      r4,|L1.900|
00027a  6824              LDR      r4,[r4,#0]
00027c  f024043c          BIC      r4,r4,#0x3c
000280  f0440420          ORR      r4,r4,#0x20
000284  4d3f              LDR      r5,|L1.900|
000286  602c              STR      r4,[r5,#0]
;;;206    
;;;207    	/* Wait I2C Tx Finish */
;;;208    	while(endflag == 0);
000288  bf00              NOP      
                  |L1.650|
00028a  4c45              LDR      r4,|L1.928|
00028c  7824              LDRB     r4,[r4,#0]  ; endflag
00028e  2c00              CMP      r4,#0
000290  d0fb              BEQ      |L1.650|
;;;209    	endflag = 0;
000292  2400              MOVS     r4,#0
000294  4d42              LDR      r5,|L1.928|
000296  702c              STRB     r4,[r5,#0]
;;;210    }
000298  bd70              POP      {r4-r6,pc}
;;;211    
                          ENDP

                  VK2C22_I2C_RDDat PROC
;;;218    *******************************************************************************/
;;;219    void VK2C22_I2C_RDDat(unsigned char Addr,unsigned char *Databuf,unsigned char cnt)
00029a  b530              PUSH     {r4,r5,lr}
;;;220    {	
00029c  4603              MOV      r3,r0
;;;221    	unsigned char i;
;;;222    	//I2C发送地址 
;;;223    	i2cdatbuf[0] = Addr;
00029e  4c3c              LDR      r4,|L1.912|
0002a0  7023              STRB     r3,[r4,#0]
;;;224    	txcnt = 0;
0002a2  2400              MOVS     r4,#0
0002a4  4d39              LDR      r5,|L1.908|
0002a6  702c              STRB     r4,[r5,#0]
;;;225    	txlen=1;
0002a8  2401              MOVS     r4,#1
0002aa  4d3a              LDR      r5,|L1.916|
0002ac  702c              STRB     r4,[r5,#0]
;;;226    	endflag = 0;
0002ae  2400              MOVS     r4,#0
0002b0  4d3b              LDR      r5,|L1.928|
0002b2  702c              STRB     r4,[r5,#0]
;;;227    	//I2C接收数据
;;;228    /* I2C function to read data from slave */
;;;229    	i2c0handlerflag = (I2C_FUNC)I2C_MasterRx;
0002b4  f2af2491          ADR      r4,I2C_MasterRx + 1
0002b8  4d33              LDR      r5,|L1.904|
0002ba  602c              STR      r4,[r5,#0]  ; i2c0handlerflag
;;;230    
;;;231    	rxcnt = 0;
0002bc  2400              MOVS     r4,#0
0002be  4d36              LDR      r5,|L1.920|
0002c0  702c              STRB     r4,[r5,#0]
;;;232    	rxlen=cnt;
0002c2  4c36              LDR      r4,|L1.924|
0002c4  7022              STRB     r2,[r4,#0]
;;;233    
;;;234    	I2C_SET_CONTROL_REG(I2C0, I2C_CTL_STA);
0002c6  4c2f              LDR      r4,|L1.900|
0002c8  6824              LDR      r4,[r4,#0]
0002ca  f024043c          BIC      r4,r4,#0x3c
0002ce  f0440420          ORR      r4,r4,#0x20
0002d2  4d2c              LDR      r5,|L1.900|
0002d4  602c              STR      r4,[r5,#0]
;;;235    
;;;236    	/* Wait I2C Rx Finish */
;;;237    	while(endflag == 0);
0002d6  bf00              NOP      
                  |L1.728|
0002d8  4c31              LDR      r4,|L1.928|
0002da  7824              LDRB     r4,[r4,#0]  ; endflag
0002dc  2c00              CMP      r4,#0
0002de  d0fb              BEQ      |L1.728|
;;;238    	for(i=0;i<cnt;i++)
0002e0  2000              MOVS     r0,#0
0002e2  e008              B        |L1.758|
                  |L1.740|
;;;239    	{
;;;240    		*Databuf++=i2cdatbuf[txlen+i]; //显示数据是低位先读
0002e4  4c2b              LDR      r4,|L1.916|
0002e6  7824              LDRB     r4,[r4,#0]  ; txlen
0002e8  4404              ADD      r4,r4,r0
0002ea  4d29              LDR      r5,|L1.912|
0002ec  5d2c              LDRB     r4,[r5,r4]
0002ee  f8014b01          STRB     r4,[r1],#1
0002f2  1c44              ADDS     r4,r0,#1              ;238
0002f4  b2e0              UXTB     r0,r4                 ;238
                  |L1.758|
0002f6  4290              CMP      r0,r2                 ;238
0002f8  dbf4              BLT      |L1.740|
;;;241    	}
;;;242    }
0002fa  bd30              POP      {r4,r5,pc}
;;;243    
                          ENDP

                  main PROC
;;;250    *******************************************************************************/
;;;251    int main(void)
0002fc  bf00              NOP      
0002fe  bf00              NOP      
000300  bf00              NOP      
                  |L1.770|
000302  2059              MOVS     r0,#0x59
000304  4927              LDR      r1,|L1.932|
000306  6008              STR      r0,[r1,#0]
000308  2016              MOVS     r0,#0x16
00030a  0589              LSLS     r1,r1,#22
00030c  f8c10100          STR      r0,[r1,#0x100]
000310  2088              MOVS     r0,#0x88
000312  f8c10100          STR      r0,[r1,#0x100]
000316  06c0              LSLS     r0,r0,#27
000318  f8d00100          LDR      r0,[r0,#0x100]
00031c  2800              CMP      r0,#0
00031e  d0f0              BEQ      |L1.770|
000320  bf00              NOP      
;;;252    {
;;;253    	/* Unlock protected registers */
;;;254    	SYS_UnlockReg();
;;;255    	SYS_Init();
000322  f7fffffe          BL       SYS_Init
;;;256    	/* Lock protected registers */
;;;257    	SYS_LockReg();
000326  bf00              NOP      
000328  2000              MOVS     r0,#0
00032a  491e              LDR      r1,|L1.932|
00032c  6008              STR      r0,[r1,#0]
00032e  bf00              NOP      
;;;258    	
;;;259    	//配置PD5(SCL),PD4(SDA)脚为硬件I2C,频率100khz
;;;260    	/* Open I2C module and set bus clock */
;;;261    	I2C_Open(I2C0, 30000);  //100khz
000330  f2475130          MOV      r1,#0x7530
000334  4813              LDR      r0,|L1.900|
000336  f7fffffe          BL       I2C_Open
;;;262    	/* Set I2C Slave Addresses */
;;;263    	I2C_SetSlaveAddr(I2C0, 0, VK2C22_ADDR, 0);   
00033a  2300              MOVS     r3,#0
00033c  223f              MOVS     r2,#0x3f
00033e  4619              MOV      r1,r3
000340  4810              LDR      r0,|L1.900|
000342  f7fffffe          BL       I2C_SetSlaveAddr
;;;264    	/* Enable I2C interrupt */
;;;265    	I2C_EnableInt(I2C0);
000346  480f              LDR      r0,|L1.900|
000348  f7fffffe          BL       I2C_EnableInt
;;;266    	NVIC_EnableIRQ(I2C0_IRQn);
00034c  2026              MOVS     r0,#0x26
00034e  f000021f          AND      r2,r0,#0x1f
000352  2101              MOVS     r1,#1
000354  4091              LSLS     r1,r1,r2
000356  0942              LSRS     r2,r0,#5
000358  0092              LSLS     r2,r2,#2
00035a  f10222e0          ADD      r2,r2,#0xe000e000
00035e  f8c21100          STR      r1,[r2,#0x100]
000362  bf00              NOP      
;;;267    		
;;;268    	VK2C22_Main();
000364  f7fffffe          BL       VK2C22_Main
;;;269    	
;;;270    	
;;;271    	while(1)
000368  bf00              NOP      
                  |L1.874|
00036a  e7fe              B        |L1.874|
;;;272    	{					
;;;273    	}
;;;274    }	
;;;275    /************************END OF FILE****/
                          ENDP

                  I2C_STOP PROC
;;;367     */
;;;368    static __INLINE void I2C_STOP(I2C_T *i2c)
00036c  6801              LDR      r1,[r0,#0]
;;;369    {
;;;370    
;;;371        (i2c)->CTL |= (I2C_CTL_SI_Msk | I2C_CTL_STO_Msk);
00036e  f0410118          ORR      r1,r1,#0x18
000372  6001              STR      r1,[r0,#0]
;;;372        while(i2c->CTL & I2C_CTL_STO_Msk);
000374  bf00              NOP      
                  |L1.886|
000376  6801              LDR      r1,[r0,#0]
000378  f0010110          AND      r1,r1,#0x10
00037c  2900              CMP      r1,#0
00037e  d1fa              BNE      |L1.886|
;;;373    }
000380  4770              BX       lr
;;;374    
                          ENDP

000382  0000              DCW      0x0000
                  |L1.900|
                          DCD      0x40080000
                  |L1.904|
                          DCD      i2c0handlerflag
                  |L1.908|
                          DCD      txcnt
                  |L1.912|
                          DCD      i2cdatbuf
                  |L1.916|
                          DCD      txlen
                  |L1.920|
                          DCD      rxcnt
                  |L1.924|
                          DCD      rxlen
                  |L1.928|
                          DCD      endflag
                  |L1.932|
                          DCD      0x40000100

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  i2cdatbuf
                          %        40

                          AREA ||.data||, DATA, ALIGN=2

                  i2c0handlerflag
                          DCD      0x00000000
                  rxdummy
000004  00                DCB      0x00
                  txlen
000005  00                DCB      0x00
                  txcnt
000006  00                DCB      0x00
                  rxlen
000007  00                DCB      0x00
                  rxcnt
000008  00                DCB      0x00
                  endflag
000009  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\User\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_endflag____REV16|
#line 114 "..\\..\\..\\Library\\CMSIS\\Include\\core_cmInstr.h"
|__asm___6_main_c_endflag____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_endflag____REVSH|
#line 128
|__asm___6_main_c_endflag____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
